#include <iostream>
#include <ctime>
#include <math.h>

#include <eigen/Eigen/Dense>
#include <cstdlib>
#include <random>
#define EIGEN_DONT_VECTORIZE
#define EIGEN_DISABLE_UNALIGNED_ARRAY_ASSERT

using Eigen::MatrixXd;
using Eigen::MatrixXi;
using Eigen::VectorXd;

//void translationSSA_general(double* kelong, double* t_array, double kbind, double kcompl, int* SSA_result, int N, int* stop_sites, int FRAP, int Inhibitor, double inhibit_time, int seed, double* SSA_ribtimes, int* nribs, int ribtimesize, int fNt, int* frap_result, int cNt, int* col_result,int ASL, double ki_alt)

void translationSSA_general(double* kelong, double* t_array, int* SSA_result, int N, double* inhibitors, int seed, double* SSA_ribtimes, int* nribs, int ribtimesize, int fNt, int* frap_result, int cNt, int* col_result, double* k_enters, double* k_pauses,double* k_stops,double* k_jumps )
{
    // Declare the variables
    int R = 9; // ribosome exclusion.
    int N_rib = 200; // maximum number of ribosomes. 
	srand(seed);
    int it = 0;
	int number_ribs = 0;
	int fit = 0;
	
	int nrxns = 0;
	//N is gene length
	int additional_rxns_cnt = 0;
	int binds = 0;
	int add_index = 0;
	int add_index_2 = 0;
	bool extra_reactions = false;
	
	int Nt = sizeof(t_array)/sizeof(*t_array); // get number of time points
	
	int n_jumps =sizeof(k_jumps)/sizeof(*k_jumps)/3; 
	int n_pauses = sizeof(k_pauses)/sizeof(*k_pauses)/2; 
	int n_stops = sizeof(k_stops)/sizeof(*k_stops)/2; 
	int n_enters = sizeof(k_enters)/sizeof(*k_enters)/2; 
	
	
	MatrixXi jumps(n_jumps,3);  // set up matrices of these reactions 
	MatrixXi pauses(n_pauses,2);
	MatrixXi stops(n_stops,2);
	MatrixXi enters(n_enters,2);
	

	
	
	int n_rxns = n_jumps+n_enters+n_pauses+n_stops;
	
	Eigen::VectorXd important_locs;
	important_locs.setZero(n_jumps+n_enters+n_pauses+n_stops);
	
	// first map all the passed new reactions to matrices for easier handling
	
	int k = 0;
	for(int i=0; i <= n_jumps; i++){
		important_locs(k) = jumps(i,0)
		jumps(i,0) = k_jumps(3*i+0)
		jumps(i,1) = k_jumps(3*i+1)
		jumps(i,2) = k_jumps(3*i+2)
		
	}			

	for(int i=0; i <= n_enters; i++){   
		enters(i,0) = k_enters(2*i+0)
		enters(i,1) = k_enters(2*i+1)
		
	}		
	
	for(int i=0; i <= n_stops; i++){
		important_locs(k) = stops(i,0)
		stops(i,0) = k_stops(2*i+0)
		stops(i,1) = k_stops(2*i+1)		
	}		
	
	for(int i=0; i <= n_pauses; i++){
		important_locs(k) = pauses(i,0)
		pauses(i,0) = k_pauses(2*i+0)
		pauses(i,1) = k_pauses(2*i+1)		
	}			
    // int N = 10; // gene length
    //bool Inhibitor = 0;
    //bool FRAP = 0;
    double Inhibit_condition=1;
    bool inhibit_off=1;
	//double inhibit_time
    double inhibit_time = 0;
	
	bool inhibitor_pres=0;
	bool FRAP_pres =0;
	
	// inhibitors = [ harringtonine-bool, FRAP-bool, time]
	
	if (inhibitors(0)==1){
		inhibitor_pres =1;
	}
	if (inhibitors(1)==1){
		FRAP_pres =1;
	}	
	
	if (inhibitor_pres || FRAP_pres){
		inhibit_time = inhibitors(2)
	}		
	
	
    int NR = 0;
	int old_NR = 0;
//	N = 10;
    double a0, r1, r2, t, tf;
    t=t_array[0];
    tf = t_array[Nt-1];
    int ind = 0;
	int transferX;
    //srand (1537478928);  
	//std::cout << time(NULL) << std::endl;
    // print a test random number
    // Define the state vector
    MatrixXi X(1,N_rib);
    X.setZero(1,N_rib);
	
	MatrixXi col(1,N_rib);
	col.setZero(1,N_rib);
	
    MatrixXi T(1,N_rib); //ribosome travel time array
    T.setZero(1,N_rib);
	
	//VectorXd T_array(200);
	int t_counter = 0;
	
    // Create an eigen matrix that stores the results. 
    Eigen::Map<Eigen::MatrixXi> X_array(SSA_result,Nt,N_rib);
	
	Eigen::Map<Eigen::MatrixXi> frap_array(frap_result,fNt,N_rib);
	
	
	int asl_free = 0;
	
	Eigen::Map<Eigen::VectorXd> T_array(SSA_ribtimes,ribtimesize);
	Eigen::Map<Eigen::VectorXi> col_array(col_result,cNt);
	Eigen::Map<Eigen::VectorXi> n_ribs(nribs,1);
	
	MatrixXi spatial_X(1,N_rib);

	int tsize = T_array.size();

    while( t < tf)
    {
        //std::cout << "-------t=" << t << "-------" << std::endl;
        // Determine inhibitor stuff
        if (inhibitor_pres) {
            if (t>=inhibit_time){
                inhibit_off = 0;
                Inhibit_condition = 0;
            } else {
                inhibit_off = 1; 
                Inhibit_condition=1;
            }}
        else { 
            Inhibit_condition=1;
        }


		
        // Update the number of ribosomes, always making sure to have
        // a zero on the right side of X (space for a new ribosome) 
		
        int NR = 0;
        while (X(0,NR)>0){
            NR+=1;
        }
		

		
		
		if (NR > old_NR){

			T(0,NR-1) = t;
			number_ribs +=1;
			
			
		}


        old_NR = 0;
        while (X(0,old_NR)>0){
            old_NR+=1;
			
        }
			
		nrxns = 0;
		binds = 0;
		
		spatial_X.setZero();
		spatial_X.topLeftCorner(1,NR+1) = (X - (X>N)-(X > (2*N-1)))%N // convert to spatial locs
		
		// parse the binds first because they change the stoich column count
		additional_rxns_cnt = 0;
		
		
		
		Eigen::VectorXd wn_bind;
        
		
		for (int i = 0; i <=n_enters; i++){
			
			bool loc_free = ((spatial_X-enters(i,0)).abs() > R).any()  // is this location free?
			if (loc_free){
				binds +=1;
				
				if (binds == 1){
					bind_events MatrixXd(1,NR+1);
					bind_events(0,NR+1) = enters(i,0);
					additional_rxns_cnt+=1;
					wn_bind.setZero(1);
					wn_bind(0) = enters(i,1);
					
				}
				else{
					bind_events.conservativeResize(bind_events.rows()+1,bind_events.cols()+1);
					bind_events(binds,NR+1) = enters(i,0);
					additional_rxns_cnt+=1;
					wn_bind.conservativeResize(1,wn_bind.cols()+1);
					wn_bind(wn_bind.cols()) = enters(i,1);
					
				}
			}
		}
		
		extra_reactions = false;
		for (int i = 0; i <= n_jumps+n_pauses+n_stops; i++){
			if ((X-important_locs(i))== 0).any(){
				extra_reactions = true;
			}			
		}
		
		
		
		if (extra_reactions){ 
			//handle the pauses now
			add_index = 0;
			add_index_2 = 0;
			
			Eigen::VectorXd wn_pauses;
			
			for (int i = 0; i <=n_pauses; i++){
				bool loc_free = ((X.head(NR)-pauses(i,0))== 0).any()   //if there is a ribosome in the pause position
				
				
				if (loc_free){
					
					
					//for (int j = 0; j <=n_pauses; j++){
						//if ( abs(X(j)-pauses(i,0)) > R){
						//	add_index = j
						//}
					//}
					
					if (add_index == 0){
						pause_events MatrixXd(1,NR+binds);
						pause_events.setZero(1,NR+binds);
						add_index += 1;
						additional_rxns_cnt+=1;
						wn_pauses.setZero(1);
						wn_pauses(0) = pauses(i,1);

					}
					else{
						pause_events.conservativeResize(pause_events.rows()+1,pause_events.cols())
						pause_events.setZero(add_index,NR+binds)
						add_index += 1;
						additional_rxns_cnt+=1;
						wn_pauses.conservativeResize(1,wn_pauses.cols()+1);
						wn_pauses(wn_pauses.cols()) = pauses(i,1);						
					}
				}
				
				
			}


			// handle jumps
			add_index = 0;
			add_index_2 = 0;
			
			Eigen::VectorXd wn_jumps;
			
			for (int i = 0; i <=n_jumps; i++){
				bool on_jump = ((X.head(NR)-jumps(i,0))== 0).any() 
				
				add_index = 0;
				if (on_jump){
					
					
					for (int j = 0; j <=n_jumps; j++){
						if ( X(0,j) == jumps(i,0)){
							add_index_2 = j
						}
					}
					
					if (binds == 1){
						jump_events MatrixXd(1,NR+binds);
						jump_events.setZero(1,NR+binds);
						add_index +=1;
						additional_rxns_cnt+=1;
						wn_jumps.setZero(1);
						wn_jumps(0) = jumps(i,2);						
					}
					else{
						jump_events.conservativeResize(jump_events.rows()+1,jump_events.cols())
						jump_events.setZero(add_index,NR+binds)
						jump_events(add_index,add_index_2) = jumps(i,1)-jumps(i,0)
						add_index +=1;
						additional_rxns_cnt+=1;
						wn_jumps.conservativeResize(1,wn_jumps.cols()+1);
						wn_jumps(wn_jumps.cols()) = jumps(i,2);							
					}
				}
				
				
			}

			//handle stops
			add_index = 0;
			add_index_2 = 0;
			
			Eigen::VectorXd wn_stops;
			for (int i = 0; i <=n_stops; i++){
				bool on_stop = ((spatial_X-stops(i,0))== 0).any() 
				
				add_index = 0;
				if (on_stop){
					
					
					for (int j = 0; j <=n_stops; j++){
						if ( X(0,j) == stops(i,0)){
							add_index_2 = j
						}
					}
					
					if (binds == 1){
						stop_events MatrixXd(1,NR+binds);
						stop_events.setZero(1,NR+binds);
						add_index +=1;
						additional_rxns_cnt+=1;
						wn_stops.setZero(1);
						wn_stops(0) = stops(i,1);						
					}
					else{
						stop_events.conservativeResize(stop_events.rows()+1,stop_events.cols())
						stop_events.setZero(add_index,NR+binds)
						stop_events(add_index,add_index_2) = -stops(i,0)
						add_index +=1;
						additional_rxns_cnt+=1;
						wn_stops.conservativeResize(1,wn_stops.cols()+1);
						wn_stops(wn_stops.cols()) = stops(i,1);							
						
					}
				}
				
				
			}
		}
				
        //std::cout << "X: " << X << std::endl;
        MatrixXi Sn_elong(NR,NR+binds);
        Sn.topLeftCorner(NR,NR).setIdentity();
        
        Eigen::VectorXd wn;
        wn.setZero(NR);
        // for loop instead of "where"       
        // also, account for the exclusion here.
        for(int i=0; i <= NR; i++)
        {
            if( X(0,i) > 0 ){
                wn(i) = kelong[X(0,i)-1];
            }
            if( i>0){
                if( X(0,i-1)%N-X(0,i)%N<=R ){
                    wn(i) = 0;
                }
                
            }
        }
		
		Eigen::VectorXd wn_all_rxns(wn.size() + wn_bind.size() + wn_pauses.size()+ wn_jumps.size()+ wn_stops.size());
		wn_all_rxns << wn, wn_bind, wn_pauses,wn_jumps,wn_stops;
		
		
		Eigen::MatrixXi Sn(Sn_elong.rows()+additional_rxns_cnt,Sn.cols());
		Sn << Sn_elong,bind_events,pause_events,jump_events,stop_events;
		
		

		
		
        // If a nascent protein reaches full length
        // add in the completion rate
//       std::cout  << X << std::endl;
/*         if( ((X(0,0)%N) == 0) && (X(0,0) !=0) ){
            // shift everyone if completing
            for(int i=0; i <= NR-1; i++)
            {
                Sn(0,i) = X(0,i+1) - X(0,i); 
            }
            Sn(0,NR-1) = -X(0,NR-1);
            wn(0) = kcompl;
//            std::cout << "Updated propensity: \n" << wn << std::endl;
//            std::cout << "Updated stoichiometry: \n " << Sn << std::endl;
        }
		
		
        // include the initiation condition
        if( (NR==0) || ( X(0,NR-1) > R) ){
            wn(NR) = kbind*Inhibit_condition;
        }
		 */
		

        // Update the propensity
        a0 = wn_all_rxns.sum();

        // Generate some random numbers.
		
        r1 =  ((double) rand()/ (RAND_MAX));
        r2 =  ((double) rand() / (RAND_MAX));
		
		
		// if rand() gets a 0 resample, since ln(0) = -inf 
		if((r1==0)){
			//std::cout << r1 << " " << r1a << " " << t <<  std::endl;
			
			r1 =  ((double) rand() / (RAND_MAX));			
		}
		
		

        // Update the time vector
//        std::cout << "TIME " << t << std::endl;
        t -= log(r1)/a0;
		//std::cout << t << std::endl;
/* 		if((t > inhibit_time) && (t < inhibit_time+30)){
			std::cout << "TIME " << t << std::endl;
			std::cout << wn << std::endl;
			std::cout << X << std::endl;
		}
		 */
		
        //std::cout << "TIME " << t << std::endl;
  //      std::cout << "-------------" << std::endl;
        // Store the X vector
        //while( ((it<=Nt-1) || (t>t_array[it])) ){
        while( (it<=Nt-1) && (t>t_array[it])) {
			//std::cout << it << std::endl;
            X_array.row(it) = X.row(0);
			
			if (FRAP_pres){
				
				if ( (t>= inhibit_time) && (t< inhibit_time+20)) {
					frap_array.row(fit) = X.row(0);
					fit +=1;
				}
			}			
			
            it+=1;
			//std::cout << it << std::endl;
			
         }
		 

		
        // update the state
        ind = 1;
        while (wn_all_rxns.head(ind).sum() < r2*a0)
        {	
            ind +=1;
        }
		
        //std::cout << "Stoichiometry of reaction: " << Sn.row(ind-1) << std::endl;
        



		
        X.topLeftCorner(1,NR+1) = X.topLeftCorner(1,NR+1) + Sn.row(ind-1);


		
		//std::cout << "rxn "<< Sn.row(ind-1).sum() << std::endl;

		if (ind > NR+1){  // alternative reaction
		
		
			if (Sn.row(ind-1).sum() < 0){ //something left the system
			
				if (t_counter < tsize){
					T_array(t_counter) = t - T(0,0);
							
					T.block(0,0,1,NR) = T.block(0,1,1,NR);
					T(0,NR) = 0;	
					
					col_array(t_counter) = col(0,0);	
					col.block(0,0,1,NR) = col.block(0,1,1,NR);	
					col(0,NR)= 0;
					t_counter +=1;		
					
				}
				
				for(int i =0; i<=NR;i++){
					if (X(0,i) == 0){
						int removed_rib = i;
						
					}
				}
				for(int i=removed_rib; i <= NR; i++){// shift everyone if completing
					
					X(0,i) = X(0,i+1); 
						
					
				}
			}
		}
		
		
		if((ind <= NR+1)){  // if something elongated and hit another ribosome, record it.
			
			if (X(0,ind-2) == X(0,ind-1) + R){
				col(0,ind-1) +=1;
			}
			
		}
/* 			if (Sn.row(ind-1).sum() < 0){  // something left the system with this reaction

				if (t_counter < tsize){
					T_array(t_counter) = t - T(0,0);
							
					T.block(0,0,1,NR) = T.block(0,1,1,NR);
					T(0,NR) = 0;	
					
					col_array(t_counter) = col(0,0);	
					col.block(0,0,1,NR) = col.block(0,1,1,NR);	
					col(0,NR)= 0;
					t_counter +=1;		
					
				}
				
				
				for(int i =0; i<=NR;i++){
					if (X(0,i) == 0){
						int removed_rib = i;
						
					}
				for(int i=removed_rib; i <= NR; i++){// shift everyone if completing
					
					X(0,i) = X(0,i+1); 
						
					
					}
				
                if( ((X(0,0)%N) == 0) && (X(0,0) !=0) ){
            // shift everyone if completing
				for(int i=0; i <= NR-1; i++)
				{
					Sn(0,i) = X(0,i+1) - X(0,i); 
				}				
					 */
					
/* 				}
				else {
					if (X(0,ind-2) == X(0,ind-1) + R){
						col(0,ind-1) +=1;
					}


			}
			//std::cout << "oneiter" << std::endl;
		} */
/* 		transferX = -1;
		if((ind == NR+2)){
			//std::cout << "altstart" << std::endl;
			//std::cout << X << std::endl;
			if((NR != 0)){
				transferX = -1;
				for(int i=0; i <= NR; i++){
					
					
					
					
					if (transferX == -1){
						//std::cout << "transferx" << std::endl;
						if((X(0,i)) < ASL && (X(0,i))!=0 ){
							transferX = 1;
							
							
							for(int j=NR+1; j >= i; j--){
								
								//std::cout << X << std::endl;
								X(0,j+1) = X(0,j);
								
							}
							
							//std::cout << X << std::endl;
							X(0,i) = ASL+N+1;
							X(0,NR+1) = 0;
							//std::cout << "adding rib" << std::endl;
							//std::cout << X << std::endl;
							
							
							
						}
						
					}
				}
			}
			else{
				X(0,0) = ASL+N+1;
				
			} */

					
			
				
					
			//std::cout << X << std::endl;
		
	
		
		
    
	
	
		} 
	n_ribs(0) = number_ribs;		
	}	

 
/*
int main()
{
    //double k[2][5] = {{1, 2, 3, 4, 5},{6,7,8,9,10}};
    //double k[1][10] = {{3.1,3.2,3.3,3.4,3.5,3.1,3.2,3.3,3.4,3.5}};
    double k[10] = {3.1,3.2,3.3,3.4,3.5,3.1,3.2,3.3,3.4,3.5};
    double t_array[3] = {0, 50,100};
    double kbind = 9.0; 
    double kcompl = 15.0; 
	double inhibit_time = 10.0;
	int FRAP = 0;
	int Inhibitor = 1;
    int Nt;
    int result[10];
	double ribtimes[50];
	int seed;
    //seed = srand (time(NULL));
    Nt = (sizeof(t_array)/sizeof(*t_array));
    for(int kk=0; kk<3; kk++){
        translationSSA(k, t_array, 3, kbind, kcompl, result, 10, FRAP, Inhibitor, inhibit_time,15,ribtimes);
    }
}   

*/
